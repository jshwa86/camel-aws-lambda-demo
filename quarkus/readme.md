# Quarkus

This project demonstrates how it would look to use [Camel Quarkus](https://quarkus.io/guides/camel) and AWS Lambda.

There are two execution models relevant when using Quarkus. 'Standard' (also called JVM) and 'Native'. For the purposes of this demo, I'll define these as follows:
* Standard/JVM: Runs on the typical JVM platform that you are already familiar with, if you are a Java developer
* Native: Does not require a JVM, instead, the entire app is pre-compiled such that the whole program is one executable file

The focus of this demo project is to show *how* to do this, so I am not going to go into lots of detail as to the difference between these two execution models.

In large part, I think a lot of the pain/problems I ran into are because I'm doing this on a Windows machine, and the majority of examples assumed a Linux based system.

## Standard/JVM build, deploy and notes

1. Build from command line: `mvn clean install`
2. Fix the `target/manage.sh` file. This file is automatically generated during the build, but for whatever reason it is malformed. Find/Replace this:
    `ZIP_FILE=fileb:///C:/` with this: `ZIP_FILE=fileb://C:/` - For whatever reason, the generated shell script has an extra slash that makes it not work (on Windows, anyway)
3. Run `sh target/manage.sh create`
    * Note: If you are using a windows machine, you can use git bash. If you installed git bash then you can just use git bash directly, or you can use the `sh.exe` under its `bin` folder.
    This command will use the AWS CLI to deploy the app, as a Lambda function, to AWS. There is a lot of background work involved in getting that all set up.
      TODO: Add more info around that setup
4. Execution results
    Upon successful deployment to AWS, you can test this Lambda function. I saw results like: 
   ```
   {
    "statusCode": 200,
    "headers": {
    "X-Custom-Header": "application/json",
    "Content-Type": "application/json"
    },
    "body": "delectus aut autem",
    "isBase64Encoded": null
    }
   ```
   I also want to call special attention to these extra metrics AWS handed to me:
    * Init duration = 3340.88 ms
    * Duration = 7237.21 ms
    * Billed duration = 7238 ms  
    * Max memory used = 183 MB
   * Memory allocated = 256 MB

## Native build, deploy, and notes

1. Make sure you meet the prereqs if you want to try this. There is a pretty intense amount of set up neccessary to be able to do this. If you want to try it yourself, [start here](https://quarkus.io/guides/amazon-lambda). There are also reference links at the end of this document that will help.
2. From the **vcvars64.bat** shell (a special requirement for Windows machines!) run this to perform the build:
    `mvn clean install -Pnative -Dquarkus.native.container-build=true`
    This will take a long time to complete. Be patient.
3. Fix the `target/manage.sh` file. This file is automatically generated during the build, but for whatever reason it is malformed. Find/Replace this:
    `ZIP_FILE=fileb:///C:/` with this: `ZIP_FILE=fileb://C:/` - For whatever reason, the generated shell script has an extra slash that makes it not work (on Windows, anyway)
4. Run `sh target/manage.sh native create`
* Note: If you are using a windows machine, you can use git bash. If you installed git bash then you can just use git bash directly, or you can use the `sh.exe` under its `bin` folder.
This command will use the AWS CLI to deploy the app, as a Lambda function, to AWS. There is a lot of background work involved in getting that all set up.
  TODO: Add more info around that setup
5. Execution results
   Upon successful deployment to AWS, you can test this Lambda function. I saw results like:
   ```
   {
    "statusCode": 200,
    "headers": {
    "X-Custom-Header": "application/json",
    "Content-Type": "application/json"
    },
    "body": "delectus aut autem",
    "isBase64Encoded": null
    }
   ```
   I also want to call special attention to these extra metrics AWS handed to me:
    * Init duration = 419.40 ms
    * Duration = 362.25 ms
    * Billed duration = 782 ms
    * Max memory used = 105 MB
    * Memory allocated = 256 MB

## Last high-level observations

If you review the results of these two executions, you'll see that the native image compile is **much much** faster in terms of initial start up time (3340.88 ms versus 419.40 ms). This is the main result I was after in this exercise and the main takeaway.

## Notes concerning setup / things I wish I knew going into this

By far the worst/hardest part of getting this all going is the initial set up. There are many tools that need to be set up and installed. Here is a rough list to give you an idea of what is involved:

* AWS CLI (for interacting with AWS)
* AWS SAM (for testing serverless apps locally - this demo doesn't talk about this, but you want to know about this, trust me)
* GraalVM
* The windows/microsoft specific C compile environment (this one really threw me for a loop, see [this(https://www.graalvm.org/docs/getting-started/windows/#prerequisites-for-using-native-image-on-windows)])
    For this you need to install the visual studio workload package mentioned in the link above.
    Once it is installed, you can lauch a command shell from the file vcvars64.bat provided by this install; **this is required** if you want to build native images on your machine

## Reference links / more information

It took me a fair amount of time to produce this demo and it was mostly cobbled together from other examples online. This section is a list of links that I found helpful while putting this together, so that others can see the same info.

* The official Quarkus and AWS Lambda walkthrough: https://quarkus.io/guides/amazon-lambda
* The Camel Quarkus examples inventory: https://camel.apache.org/camel-quarkus/latest/user-guide/examples.html
* This github issue finally gave me a solution to producing working native image builds on Windows: https://github.com/quarkusio/quarkus/issues/5340
* Quarkus guide to building a native image: https://quarkus.io/guides/maven-tooling#build-a-container-friendly-executable
* AWS specific guide to using Quarkus: https://aws.amazon.com/blogs/architecture/field-notes-optimize-your-java-application-for-aws-lambda-with-quarkus/
* GraalVM install guide on windows: https://www.graalvm.org/docs/getting-started/windows/
* GraalVM native image installer guide: https://www.graalvm.org/reference-manual/native-image/#install-native-image
* Blog post with more detailed info around the setup required to do native builds on windows: http://dplatz.de/blog/2020/quarkus-native-image-windows.html
* Camel Quarkus user guide: https://camel.apache.org/camel-quarkus/latest/user-guide/
* Camel Quarkus notes concerning 'native mode': https://camel.apache.org/camel-quarkus/latest/user-guide/native-mode.html
* AWS Quarkus sample repo: https://github.com/aws-samples/aws-quarkus-demo
* Docker-Lambda repo (I didn't use for this demo, but I think this is potentially very useful): https://github.com/lambci/docker-lambda
* Blog post that provides another view into how this all works: https://www.kabisa.nl/tech/beat-java-cold-starts-in-aws-lambdas-with-graalvm/ 
* What is GraalVM?: https://chrisseaton.com/truffleruby/jokerconf17/ - This is long, but worth a read to help understand what Graal actually is